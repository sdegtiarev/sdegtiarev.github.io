<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>std.experimental.perpetual</title>
        </head><body>
        <h1>std.experimental.perpetual</h1>
        <!-- Generated by Ddoc from perpetual.d -->
<br><br>
<dl><dt><big><a name="Perpetual"></a>struct <u>Perpetual</u>(T);
</big></dt>
<dd>Creates an object mapped to a file. The object is persistent
   and outlives the parent application. The file may be reopened
   and the object reused, it's value persists. This might be viewed
   as kind of binary serialization with the difference that access
   to the variable is almost as fast as any regular memory. The
   structure might be also used as memory shared between processes/threads,
   however, no built-in synchronization is provided.
<br><br>
If the template parameter T is immutable, the created object is also
   immutable. Note: shared memory is then created in read-only
   mode, so even cast to mutable and attempt to modify it will cause
   segmentation fault.
<br><br>

 The <u>Perpetual</u>(T) exists in two forms. When T is regular value type
   (including static arrays), Persistent(T) behaves like reference to
   the object. In the second form, Persistent(T[]), the class behaves
   as proxy to dynamic array providing slicing interface. Note, even
   in this case, elements of the array must be value type, no pointers
   nor references to process's memory allowed.
<br><br>

 The values created are initialized with std.conv.emplace using
  additional arguments if any. The object remains in valid state
  until the file is deleted or modified.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.stdio;
<font color=blue>import</font> std.file : remove, exists, deleteme;

<font color=green>// custom data examples
</font><font color=blue>struct</font> A { <font color=blue>int</font> x; };
<font color=blue>class</font> B {};
<font color=blue>enum</font> Color { black, red, green, blue, white };

string[] file;
<font color=blue>foreach</font>(i; 0..8) file~=deleteme~to!string(i);
<font color=blue>scope</font>(exit) <font color=blue>foreach</font>(f; file[]) <font color=blue>if</font>(exists(f)) remove(f);

<font color=green>/// Part 1: create mapped variables
</font>{
    <font color=green>// simle int variable initialized with default value
</font>    <font color=blue>auto</font> p0=<u>Perpetual</u>!<font color=blue>int</font>(file[0]);
    <font color=blue>assert</font>(p0 == <font color=blue>int</font>.init);
    p0=7;
    <font color=blue>assert</font>(p0 == 7);

    <font color=green>// single double value initialized in ctor
</font>    <font color=green>// , would throw if the file did exist.
</font>    <font color=blue>auto</font> p1=<u>Perpetual</u>!<font color=blue>double</font>(file[1], 2.71828);
    <font color=blue>assert</font>(p1 == 2.71828);
    p1=3.14159;

    <font color=green>// struct, initialized in ctor
</font>    <font color=blue>auto</font> p2=<u>Perpetual</u>!A(file[2], 22);
    <font color=blue>assert</font>(p2.x == 22);
   
    <font color=green>// static array of integers, assignable
</font>    <font color=blue>auto</font> p3=<u>Perpetual</u>!(<font color=blue>int</font>[5])(file[3]);
    <font color=blue>assert</font>(p3[0] == <font color=blue>int</font>.init);
    p3=[1,3,5,7,9];
    <font color=blue>assert</font>(p3[0] == 1);

    <font color=green>// enum, initialized in ctor
</font>    <font color=blue>auto</font> p4=<u>Perpetual</u>!Color(file[4], Color.red);
    <font color=blue>assert</font>(p4 == Color.red);
    

    <font color=green>// character string
</font>    <font color=blue>auto</font> p5=<u>Perpetual</u>!(<font color=blue>char</font>[32])(file[5]);
    p5=<font color=red>"hello world"</font>;

    <font color=green>// second order static array
</font>    <font color=blue>auto</font> p8=<u>Perpetual</u>!(<font color=blue>char</font>[3][5])(file[6]);
    p8[]=<font color=red>"..."</font>; p8[1]=<font color=red>"one"</font>; p8[2]=<font color=red>"two"</font>;


    <font color=green>/// Compile time errors
</font>    <font color=green>// char* is reference type
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(<u>Perpetual</u>!(<font color=blue>char</font>*)(<font color=red>"?"</font>))));
    <font color=green>// B is class, reference type
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(<u>Perpetual</u>!(B)(<font color=red>"?"</font>))));
    <font color=green>// char* is reference type
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(<u>Perpetual</u>!(<font color=blue>char</font>*)(<font color=red>"?"</font>))));
    <font color=green>// char*[12] is reference type
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(<u>Perpetual</u>!(<font color=blue>char</font>*[12])(<font color=red>"?"</font>))));
    <font color=green>// char[string] is reference type
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(<u>Perpetual</u>!(<font color=blue>char</font>[string])(<font color=red>"?"</font>))));
    <font color=green>// char[] is reference type
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(<u>Perpetual</u>!(<font color=blue>char</font>[][])(<font color=red>"?"</font>))));
    <font color=green>// char[][3] is reference type
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(<u>Perpetual</u>!(<font color=blue>char</font>[][3])(<font color=red>"?"</font>))));
}
<font color=green>/// destroy everything and unmap files
</font>


<font color=green>/// Part 2: map again and check the values are preserved
</font>{
    <font color=green>// Was previosly mapped as int and assigned 7
</font>    <font color=blue>auto</font> p0=<u>Perpetual</u>!<font color=blue>int</font>(file[0]);
    <font color=blue>assert</font>(p0 == 7);
    <font color=green>// int cannot be emplaced from a double
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(<u>Perpetual</u>!<font color=blue>int</font>(<font color=red>"?"</font>, 1.0))));
    <font color=green>/// attempt to initialize immutable array
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(<u>Perpetual</u>!(<font color=blue>immutable</font>(<font color=blue>int</font>)[])(3,file[0],34))));
    <font color=green>/// The file was only 4 bytes long
</font>    <font color=green>///   , immutable storage can't be extended
</font>    assertThrown(<u>Perpetual</u>!(<font color=blue>immutable</font>(<font color=blue>int</font>)[])(3,file[0]));

    <font color=green>/// This works, extend the storage and 
</font>    <font color=green>///  init appended tail, but not existing part
</font>    <font color=blue>auto</font> p1=<u>Perpetual</u>!(<font color=blue>int</font>[])(3,file[0],123);
    <font color=blue>assert</font>(p1[0] == 7);
    <font color=blue>assert</font>(p1[1] == 123);
    <font color=blue>assert</font>(p1.length == 3);

    <font color=green>// Was previousli mapped as double and assigned 3.14159
</font>    <font color=blue>auto</font> p2=<u>Perpetual</u>!<font color=blue>double</font>(file[1]);
    <font color=blue>assert</font>(p2 == 3.14159);

    <font color=green>// struct with int member initialized with 22
</font>    <font color=blue>auto</font> p3=<u>Perpetual</u>!A(file[2]);
    <font color=blue>assert</font>(p3 == A(22));
    
    <font color=green>// Was mapped as int[5], remap as view only array of shorts
</font>    <font color=blue>auto</font> p4=<u>Perpetual</u>!(<font color=blue>immutable</font>(<font color=blue>short</font>[]))(file[3]);
    <font color=blue>assert</font>(p4.length == 10);
    <font color=green>// Assuming LSB
</font>    <font color=blue>assert</font>(p4[0] == 1 &amp;&amp; p4[2] == 3 &amp;&amp; p4[4] == 5);
    <font color=green>// cannot modify immutable expression
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(p4[1]=111)));

    <font color=green>// enum, was set to Color.red
</font>    <font color=blue>auto</font> p5=<u>Perpetual</u>!Color(file[4]);
    <font color=blue>assert</font>(p5 == Color.red);

    <font color=green>// view only variant of char[4]
</font>    <font color=blue>auto</font> p6=<u>Perpetual</u>!string(4, file[5]);
    <font color=blue>assert</font>(p6 == <font color=red>"hell"</font>);
    <font color=green>// cannot modify immutable expression
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(p6[0]='A')));
    <font color=green>// slice is not mutable
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>is</font>(<font color=blue>typeof</font>(p6[]=<font color=red>"1234"</font>)));

    <font color=green>// remap second order array as plain array
</font>    <font color=blue>auto</font> p7=<u>Perpetual</u>!(<font color=blue>const</font>(<font color=blue>char</font>[]))(file[6]);
    <font color=blue>assert</font>(p7.length == 15);
    <font color=blue>assert</font>(p7[0..5] == <font color=red>"...on"</font>);
    <font color=green>// map again as dynamic array
</font>    <font color=blue>auto</font> p8=<u>Perpetual</u>!(<font color=blue>char</font>[3][])(file[6]);
    <font color=blue>assert</font>(p8.length == 5);
    <font color=blue>assert</font>(p8[2] == <font color=red>"two"</font>);
    <font color=green>// Array lengths don't match for copy: 4 != 3
</font>    <font color=green>//p8[0]="null";
</font>
    <font color=green>// write-protected file
</font>    { File(file[7],<font color=red>"w"</font>).write(<font color=red>"12345678"</font>); }
    chmod(file[7].toStringz, octal!444);
    <font color=green>// mutable array can't be mapped on read-only file 
</font>    assertThrown(<u>Perpetual</u>!(<font color=blue>int</font>[])(file[7]));
    <font color=green>// immutable array can be mapped
</font>    <font color=blue>auto</font> p9=<u>Perpetual</u>!(<font color=blue>immutable</font>(<font color=blue>int</font>)[])(file[7]);
    <font color=blue>assert</font>(p9.length == 2);

}
</pre>
<br><br>
<dl><dt><big><a name="Perpetual.Ref"></a>@property Element[] <u>Ref</u>();
</big></dt>
<dd>Proxy to underlying dynamic array type.
  Forwards calls to opSlice(), length() etc<br><br>

</dd>
<dt><big><a name="Perpetual.toString"></a>const @property void <u>toString</u>(scope void delegate(const(char)[]) <i>sink</i>, FormatSpec!char <i>fmt</i>);
</big></dt>
<dd>Convert to string the value, not the class itself<br><br>

</dd>
<dt><big><a name="Perpetual.initIndex"></a>const @property auto <u>initIndex</u>();
</big></dt>
<dd>Index of uninitialized part of the array<br><br>

</dd>
<dt><big><a name="Perpetual.master"></a>const @property auto <u>master</u>();
</big></dt>
<dd>If whole or part of the file was created and
  was initialized in constructor, return <b>true</b>.
    For scalar types this means, the entire object was constructed.
  For dynamic arrays initIndex() shows first initialized
  elsement.<br><br>

</dd>
<dt><big><a name="Perpetual.this"></a>this(Arg...)(string <i>path</i>, Arg <i>arg</i>);
</big></dt>
<dd>Universal constructor, for both scalar and array types.
 Opens file and assosiates object with it.
 The file is extended if required.
 The object is initialized if file was created or extended.<br><br>

</dd>
<dt><big><a name="Perpetual.this.2"></a>this(Arg...)(size_t <i>len</i>, string <i>path</i>, Arg <i>arg</i>) if (dynamic);
</big></dt>
<dd>Open file and map dynamic array to it.
 Creates array of requested length, file is extended if necessary<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="shMem"></a>ShMem <u>shMem</u>(string <i>path</i>, size_t <i>len</i>, ShMem.Mode <i>mode</i> = ShMem.Mode.readWrite);
</big></dt>
<dd>class factory function<br><br>

</dd>
<dt><big><a name="shMem.2"></a>ShMem <u>shMem</u>(string <i>path</i>, ShMem.Mode <i>mode</i> = ShMem.Mode.readWrite);
</big></dt>
<dd>class factory function<br><br>
<b>Examples:</b><br>
Using of package scoped shared memory allocator
<pre class="d_code">
<font color=blue>import</font> std.file : remove, deleteme;


string file=deleteme~<font color=red>"1"</font>;
<font color=blue>scope</font>(exit) remove(file);


{
    <font color=blue>auto</font> s1=<u>shMem</u>(file, 8);
    enforce(s1.master);
    enforce(s1.writeable);
    enforce(s1.unplowed == 0);
    enforce(s1.length == 8);

    <font color=blue>int</font>[] i=<font color=blue>cast</font>(<font color=blue>int</font>[]) s1[];
    enforce(i.length == 2);
    i[0]=12;
    i[1]=13;
}
{
    <font color=blue>auto</font> s2=<u>shMem</u>(file, 12);
    enforce(s2.master);
    enforce(s2.writeable);
    enforce(s2.unplowed == 8);
    enforce(s2.length == 12);

    <font color=blue>int</font>[] i=<font color=blue>cast</font>(<font color=blue>int</font>[]) s2[];
    enforce(i.length == 3);
    enforce(i[0] == 12);
    enforce(i[1] == 13);
}
{
    <font color=blue>auto</font> s3=<u>shMem</u>(file, 4, ShMem.Mode.readOnly);
    enforce(!s3.master);
    enforce(!s3.writeable);
    enforce(s3.unplowed == 4);
    enforce(s3.length == 4);

    <font color=blue>int</font>[] i=<font color=blue>cast</font>(<font color=blue>int</font>[]) s3[];
    enforce(i.length == 1);
    enforce(i[0] == 12);
}
{
    <font color=blue>auto</font> s4=<u>shMem</u>(file);
    enforce(!s4.master);
    enforce(s4.writeable);
    enforce(s4.unplowed == 12);
    enforce(s4.length == 12);
}
{
    assertThrown(<u>shMem</u>(file, 24, ShMem.Mode.readOnly));
}
{
    chmod(toStringz(file), octal!444);
    assertThrown(<u>shMem</u>(file, 24));
}
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
